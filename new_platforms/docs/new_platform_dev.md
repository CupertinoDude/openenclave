Development: Creating Your Own Enclave
=============

In this guide, you will learn how to create new applications that take advantage
of enclaves using the Open Enclave SDK.

# Introduction

Any application that uses the Open Enclave SDK is composed of two parts: the
host app and the enclave. The interface between the two is defined using the
[Enclave Definition
Language](https://software.intel.com/en-us/sgx-sdk-dev-reference-enclave-definition-language-file-syntax),
or EDL. EDL files describe how a host app calls into an enclave to request a
secure service (i.e. an Enclave CALL, or ECALL), and how an enclave calls into
its host app to request an insecure service (i.e. an Out CALL, or OCALL). The
same EDL file is used to define the interface between host and enclave
regardless of whether the enclave is an Intel SGX enclave or ARM TrustZone
trusted application (TA). An EDL file may include other EDL files and is
processed using the `oeedger8r` tool. This tool generates two sets of one source
file and one header file. One set is included by the host app and the other is
included by the enclave. The autogenerated files contain code to aid in the
marshalling of function calls and data across the host/enclave boundary such
that ECALLs and OCALLs appear as normal function calls to the developer. The
underlying enclave-specific behaviors are abstracted away.

# Using the SDK

This guide assumes that your project uses Git for source control, but it is not
strictly necessary. The purpose of using Git in this guide is to fetch the Open
Enclave SDK as a submodule of your project, but you could pull the source using
any other method that you choose. Additionally, the Open Enclave SDK uses
[CMake](https://cmake.org) as its build system for cross-platform build support.
The SDK exposes three CMake functions that enable you to create your own
cross-platform host app and enclave and are described in this guide.

## Directory Structure

The following is a sample directory structure for an Open Enclave project:

```
my_project
  | 3rdparty
    | openenclave [remote]
      | ...
      | new_platforms
        | ...
        | CMakeLists.txt
  | enc
    | optee
      | linux_gcc.mak
      | sub.mak
      | user_ta_header_defines.h
      | uuids.reg
    | enc.c
    | myproject_enclave_private.pem
    | myproject_enclave.config.xml
    | CMakeLists.txt
  | host
    | main.c
    | CMakeLists.txt
  | interface.edl
  | CMakeLists.txt
```

The top-level `CMakeLists.txt` file sets up the CMake basics for your project,
imports the Open Enclave SDK from the 3rdparty directory, and instructs CMake to
recurse into the `enc` and `host` subdirectories. It looks like this:

```
cmake_minimum_required(VERSION 3.12 FATAL_ERROR)

project("My Project" VERSION 0.1 LANGUAGES C CXX)

add_subdirectory(3rdparty/openenclave/new_platforms)

add_subdirectory(enc)
add_subdirectory(host)
```

The `interface.edl` file describes the interface via which the host app and TA
communicate with one another. This EDL file contains only functionality that is
specific to your project. However, it references other EDL files provided by the
Open Enclave SDK. These referenced EDL files specify the interface through which
the trusted components of the SDK, which are linked into your enclave, and the
corresponding untrusted components of the SDK, which are linked into your host
app, talk with each other. The `oeedger8r` tool processes this file and
generates code that may be called by either the trusted or the untrusted side to
transparently communicate with the other side.

The `enc` directory holds the source code for your enclave, in this case a
single `enc.c` file. Under the `optee` folder there are files that are used by
the build process for ARM TrustZone via OP-TEE. Currently, OP-TEE requires
building TAs with GNU Make and does not support CMake. The `sub.mk` file
specifies the list of sources a second time as well as per-file compiler flags,
where necessary. Similarly, the `linux_gcc.mak` file also contains a copy of the
UUID value. The `user_ta_header_defines.h` header file contains configuration
values required by OP-TEE, including the UUID as well in a C-structure format.
The `uuids.reg` registry file contains registry keys and values to register an
OP-TEE TA with the Windows Trusted Runtime.

The file `myproject_enclave_private.pem` holds the private key in PEM format
with which to sign the enclave when the target TEE is Intel SGX. The file
`myproject_enclave_config.xml` contains configuration values required by Intel
SGX.

Lastly, there is a `CMakeLists.txt` file that describes to CMake how to build
the enclave.

The `host` directory holds the code for your host app, in this case a single
`main.c` file. This file contains OS- and TEE-agnostic host code that loads the
TA and invokes the client-related functionality. Note that the code that you
write for your host app need not know how to launch an enclave under Intel SGX
or a TA under ARM TrustZone nor how to do so under both Windows and Linux.
Again, the Open Enclave SDK deals with these details on your behalf. The `host`
directory also has a `CMakeLists.txt` file that instructs CMake how to build the
host app executable.

In general then, there is an EDL file that both the trusted and untrusted
components consume that specifies how the pair communicate across the trust
boundary. The EDL file only contains functions that are specific to your use
case. The trusted component need only be written once and targets the Open
Enclave SDK's API. This way it can be seamlessly compiled as an Intel SGX
enclave and as an ARM TrustZone trusted application. Similarly, the host
programs also need only be written once and, assuming you do not make use of
OS-specific functionality, they too can be compiled into Windows and Linux
programs that can seamlessly launch and operate Intel SGX enclaves and ARM
TrustZone trusted applications.

## Building the Enclave

The `CMakeLists.txt` file under `enc` looks like this:

```
include(oeedl_file)
include(add_enclave)

oeedl_file(../interface.edl enclave GEN C_GEN H_GEN ${OE_PATH}/include)

add_enclave(
    TARGET myproject_enc
    UUID c5c9f16c-1981-11e9-ab14-d663bd873d93
    SOURCES
        enc.c
        ${GEN}
    C_GEN ${C_GEN})
```

The first two lines include the contents of two external CMake files provided by
the OpenEnclave SDK. These files make available the `oeedl_file` and
`add_enclave` functions, respectively.

The third line invokes `oeedl_file`, specying the path to your project's EDL
file and signals that `oeedger8r` should generate the set of files to include in
the enclave. After the call, the values `${GEN}`, `${C_GEN}` and `${H_GEN}`
contain the absolute paths to source and header files, the absolute path to the
source file, and the absolute path to the header file, respectively. The last
parameter indicates that `oeedger8r` should look for additional EDL files in the
`include` directory of the Open Enclave SDK, which `interface.edl` imports.

The fourth line invokes `add_enclave`. This function creates a libary target
named `myproject_enc` if the project is configured to use Intel SGX enclaves or
`c5c9f16c-1981-11e9-ab14-d663bd873d93` if the project is configured to use ARM
TrustZone (usage of a UUID is a requirement of OP-TEE). The function takes a
list of source files, including both the source and header files generated by
the call to `oeedl_file` as well as just the path to the generated source file
(also required by OP-TEE). `add_enclave` configures the target with the required
include paths, and compiler and linker flags.

When building for ARM TrustZone, the `add_enclave` function invokes the
underlying `linux_gcc.mak` Makefile against the TA Dev Kit that you specify. 

## Building the Host

The `CMakeLists.txt` file under `host` looks like this:

```
include(oeedl_file)
include(add_host)

oeedl_file(../helloworld.edl host GEN C_GEN H_GEN ${OE_PATH}/include)

add_host(
    TARGET myproject_host
    SOURCES host.c ${GEN})
```

The first line is the same as before, and the second imports the `add_host`
function, which is analogous to `add_enclave`, but for host apps instead.

The third line invokes `oeedl_file` and it behaves in the same way as before.
Note that the second parameter is now `host` instead of `enclave`. This
indicates to `oeedger8r` to generate the source and header file pair for
inclusion in a host app.

The fourth line invokes `add_host`. This function creates a target named
`myproject_host` and configures it with the required include paths, and compiler
and linker flags.

# Understanding the SDK

## Generating Calls between Enclaves and Host Apps

To use this SDK, you must define your own
[EDL](https://software.intel.com/en-us/sgx-sdk-dev-reference-enclave-definition-language-file-syntax)
file that defines any APIs you want to use, and use `oeedger8r` to generate code
from it. The same generated code will work equally with both SGX and OP-TEE, as
long as the Untrusted App and the Trusted App both use the right include paths
and libs, and the following additional code constraint is met:

OP-TEE only allows one thread per TA to be in an ECALL (i.e., a call into a TA
from a host app).  Even if it has an OCALL (i.e., an out-call back into the host
app) in progress, the ECALL must complete before another ECALL can enter the TA.
SGX, on the other hand, would allow a second ECALL to enter.  So if you want
them to function identically, host apps can pass the
`OE_ENCLAVE_FLAG_SERIALIZE_ECALLS` flag when creating an enclave to
automatically get the OP-TEE like behavior for both SGX and TrustZone.

## Include paths, preprocessor defines, and libraries

This section is informational only, CMake takes care of configuring include
paths, processor defines, compiler flags, and linker flags.

### SGX Enclave DLL

The SGX Enclave DLL should link with `oeenclave.lib` and have the following
additional include paths:

* `new_platforms\include\sgx\enclave`
* `new_platforms\include`

To use stdio APIs, the SGX Enclave DLL should link with `oestdio_enc.lib`.
See the helloworld sample for an example.

To use socket APIs, the SGX Enclave DLL should link with `oesocket_enc.lib`.
See the sockets sample for an example.

### SGX Rich Application

The EXE should link with `oehost.lib` and have the following additional
include path:

* `new_platforms\include`

To allow the SGX Enclave DLL to use stdio APIs, the EXE should link with
`oestdio_host.lib`. See the helloworld sample for an example.

To allow the SGX Enclave DLL to use socket APIs, the EXE should link with
`oesocket_host.lib`. See the sockets sample for an example.

### OP-TEE TA

The OP-TEE TA should link with `liboeenclave` and have the following
additional include paths, in this order (the order is important because files in
a deeper directory override files at higher levels with the same filename):

* `new_platforms/include/optee/enclave`
* `new_platforms/include/optee`
* `new_platforms/include`

To use stdio APIs, the OP-TEE TA should link with `liboestdio_enc`. See the
helloworld sample for an example.

To use socket APIs, the OP-TEE TA should link with `liboesocket_enc`. See the
sockets sample for an example.

### OP-TEE Rich Application

The EXE should link with `oehost.lib` and have the following additional
include paths, in any order:

* `new_platforms\include`
* `new_platforms\include\optee`
* `new_platforms\include\optee\host`

To allow the OP-TEE TA to use stdio APIs, the EXE should link with
`oestdio_host.lib`. See the helloworld sample for an example.

To allow the OP-TEE TA to use socket APIs, the EXE should link with
`oesocket_host.lib`. See the sockets sample for an example.

## Open Enclave APIs

This SDK implements the Open Enclave APIs covered in [API
docs](https://ms-iot.github.io/openenclave/api/files.html).

This SDK also provides support for a number of APIs that are not available in
SGX and/or OP-TEE.  For APIs that would normally be in some standard C header
(e.g., "stdio.h"), the convention is that instead of including *token*.h, one
would include (instead or in addition to the one provided by SGX or OP-TEE if
any), `tcps_*token*_t.h` for defines common to both SGX and OP-TEE, or
`tcps_*token*_optee_t.h` for defines unique to OP-TEE, since the Intel SGX SDK
already provides more than OP-TEE provides and such files provide the equivalent
for OP-TEE.  For example, the following such headers exist:

* `tcps_stdlib_t.h`
* `tcps_string_t.h`
* `tcps_time_t.h`

Additional OP-TEE only headers that provide support already present in SGX
include:

* `tcps_ctype_optee_t.h`
* `tcps_string_optee_t.h`

If none of the above are needed, trusted code might need to `#include
<openenclave/enclave.h>` (as well as the `*_t.h` file generated from your
application's EDL file) to get basic definitions, but it should be pulled in
automatically if any of the above are included.

Untrusted code might need to `#include <openenclave/host.h>` (as well as the
`*_u.h` file generated from your application's EDL file) to get basic
definitions.

## Dependencies

The trusted component depends on the following Open Enclave-provided libraries:

* `oeenclave`: Provides core Open Enclave functionality;
* `oesocket_enc`: Provides sockets functionality inside the TA:
    * Linking is necessary only if you use sockets;
    * This library marshals socket calls out to the host app.
* `oestdio_enc`: Provides standard I/O functionality inside the TA:
    * Linking is necessary only if you use standard I/O;
    * This library marshals standard I/O calls out to the host app.

**Note**: When using sockets or I/O APIs, or any other trusted-to-untrusted
call, the data that you send into these APIs and out to the host app is not
automatically protected.

The untrusted component depends on the following Open Enclave-provided
libraries:

* `oehost`: Provides core Open Enclave functionality;
* `oesocket_host`: Provides the implementation of the socket calls that the
  trusted component makes:
    * Linking is necessary only if you use sockets inside the trusted component.
* `oestdio_host`: Provides the implementation of the standard I/O calls that the
  trusted component makes:
    * Linking is necessary only if you use standard I/O inside the trusted
      component.

Notice how these libraries come in pairs. The libraries provide Open
Enclave-provided APIs inside the trusted component. When you call these APIs,
they in turn invoke code generated by the `oeedger8r` tool as specified by the
SDK's EDL files, included by yours. This code marshals the calls across the
trust boundary which are captured by functions implemented in the corresponding
libraries in the host app. The same is true the other way around.

# CMake Functions Reference

## oeedl_file

Wraps the processing of an EDL file.

### Signature

```
oeedl_file(
    <edl_file>
    <type>
    <out_files_var>
    <out_c_files_var>
    <out_h_files_var>
    [--edl-search-dir edl_search_paths])
```

### Description

Processes an EDL file via the `oeedger8r` tool. The function generates a source
and header file pair for inclusion in the host app if the `type` parameter is
`host` and a source and header file pair for inclusion in the enclave if it is
`enclave`. The `out_files_var` parameter specifies the name of the variable in
the caller's scope which shall contain a list of absolute paths to the source
and header files. The `out_c_files_var` parameter specifies the name of the
variable in the caller's scope which shall receive the absolute path to the
source file and the `out_h_files_var` parameter likewise for the absolute path
to the header file. The parameter names are plural in case the tool generates
more than one source and header file in the future. Specify `--edl-search-dir
path1 path2 ...` at the end to add `path1 path2 ...` to the list of paths for
the `oeedger8r` tool to look for included EDL files.

### Arguments

- `edl_file`: Path to the EDL file to process.
- `TYPE`: One of `host` or `enclave`, specifies which one of the two sets of
  autogenerated source and header files to generate.
- `out_files_var`: Name of the variable to receive the list of paths to the
  autogenerated files.
- `out_c_files_var`: Name of the variable to receive the path to the
  autogenerated source file (subset of `out_files_var`).
- `out_h_files_var`: Name of the variable to receive the path to the
  autogenerated header file (subset of `out_files_var`).
- `--edl-search-dir`: List of additional paths to search for included EDL files.

## add_enclave

Adds a CMake target to build an enclave and configures the target accordingly.

### Signature

```
add_enclave(
    <TARGET target>
    <UUID uuid>
    <SOURCES sources>
    <C_GEN c_gen>)
```

### Description

On Windows, wraps a call to `add_library` and configures the target with the
appropriate include paths, and compiler and linker flags. On Linux, wraps a call
to `add_custom_target` and invokes the underlying OP-TEE `linux_gcc.mak` with
the TA Dev Kit directory as specified to CMake during configuration. The name of
the enclave is `target` if the underlying TEE is Intel SGX or `uuid` when the
underlying TEE is ARM TrustZone via OP-TEE.

### Arguments

- `TARGET target`: Named parameter specifying the name of the enclave when the
  TEE is Intel SGX.
- `UUID uuid`: Named parameter specifying the UUID of the eclave when the TEE is
  ARM TrustZone via OP-TEE.
- `SOURCES sources`: Named parameter specifying the list of source files for the
  enclave.
- `C_GEN c_gen`: Named parameter specifying list of source files generated via a
  call to `oeedl_file` (i.e. the value of the variable named passed as
  `out_c_files_var`). This is necessary to compile an enclave for ARM TrustZone
  via OP-TEE.

## add_host

Adds a CMake target to build a host app and configures the target accordingly.

### Signature

```
add_host(
    <TARGET target>
    <SOURCES sources>)
```

### Description

Adds a CMake target with name `target` and source files `sources`, then
configures it with the required header include paths, compiler and linker flags,
and adds dependencies to the required Open Enclave libraries.

### Arguments

- `TARGET target`: Named parameter specifying the name of the host app.
- `SOURCES sources`: Named parameter specifying the list of sources for the
  enclave.
